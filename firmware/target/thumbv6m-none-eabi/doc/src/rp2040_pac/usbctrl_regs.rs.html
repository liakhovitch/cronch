<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/admin/.cargo/registry/src/github.com-1ecc6299db9ec823/rp2040-pac-0.4.0/src/usbctrl_regs.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>usbctrl_regs.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../rp2040_pac/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../rp2040_pac/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../rp2040_pac/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
</pre><pre class="rust"><code><span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">r&quot;Register block&quot;</span>]</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">C</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">RegisterBlock</span> {
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x00 - Device address and endpoint control&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp::ADDR_ENDP_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x04 - Interrupt endpoint 1. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp1</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp1::ADDR_ENDP1_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x08 - Interrupt endpoint 2. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp2</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp2::ADDR_ENDP2_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x0c - Interrupt endpoint 3. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp3</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp3::ADDR_ENDP3_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x10 - Interrupt endpoint 4. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp4</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp4::ADDR_ENDP4_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x14 - Interrupt endpoint 5. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp5</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp5::ADDR_ENDP5_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x18 - Interrupt endpoint 6. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp6</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp6::ADDR_ENDP6_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x1c - Interrupt endpoint 7. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp7</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp7::ADDR_ENDP7_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x20 - Interrupt endpoint 8. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp8</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp8::ADDR_ENDP8_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x24 - Interrupt endpoint 9. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp9</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp9::ADDR_ENDP9_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x28 - Interrupt endpoint 10. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp10</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp10::ADDR_ENDP10_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x2c - Interrupt endpoint 11. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp11</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp11::ADDR_ENDP11_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x30 - Interrupt endpoint 12. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp12</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp12::ADDR_ENDP12_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x34 - Interrupt endpoint 13. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp13</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp13::ADDR_ENDP13_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x38 - Interrupt endpoint 14. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp14</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp14::ADDR_ENDP14_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x3c - Interrupt endpoint 15. Only valid for HOST mode.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">addr_endp15</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp15::ADDR_ENDP15_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x40 - Main control register&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">main_ctrl</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">main_ctrl::MAIN_CTRL_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x44 - Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">sof_wr</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">sof_wr::SOF_WR_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x48 - Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">sof_rd</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">sof_rd::SOF_RD_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x4c - SIE control register&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">sie_ctrl</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">sie_ctrl::SIE_CTRL_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x50 - SIE status register&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">sie_status</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">sie_status::SIE_STATUS_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x54 - interrupt endpoint control register&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">int_ep_ctrl</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">int_ep_ctrl::INT_EP_CTRL_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x58 - Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">buff_status</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">buff_status::BUFF_STATUS_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x5c - Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">buff_cpu_should_handle</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">buff_cpu_should_handle::BUFF_CPU_SHOULD_HANDLE_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x60 - Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe to modify the buffer control register.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">ep_abort</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">ep_abort::EP_ABORT_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x64 - Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">ep_abort_done</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">ep_abort_done::EP_ABORT_DONE_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x68 - Device: this bit must be set in conjunction with the `STALL` bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">ep_stall_arm</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">ep_stall_arm::EP_STALL_ARM_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x6c - Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">nak_poll</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">nak_poll::NAK_POLL_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x70 - Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the endpoint control register.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">ep_status_stall_nak</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">ep_status_stall_nak::EP_STATUS_STALL_NAK_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x74 - Where to connect the USB controller. Should be to_phy by default.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">usb_muxing</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">usb_muxing::USB_MUXING_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x78 - Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable to switch over to the override value.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">usb_pwr</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">usb_pwr::USB_PWR_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x7c - This register allows for direct control of the USB phy. Use in conjunction with usbphy_direct_override register to enable each override bit.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">usbphy_direct</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">usbphy_direct::USBPHY_DIRECT_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x80 - Override enable for each control in usbphy_direct&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">usbphy_direct_override</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">usbphy_direct_override::USBPHY_DIRECT_OVERRIDE_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x84 - Used to adjust trim values of USB phy pull down resistors.&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">usbphy_trim</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">usbphy_trim::USBPHY_TRIM_SPEC</span><span class="op">&gt;</span>,
    <span class="ident">_reserved34</span>: [<span class="ident">u8</span>; <span class="number">0x04</span>],
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x8c - Raw Interrupts&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">intr</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">intr::INTR_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x90 - Interrupt Enable&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">inte</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">inte::INTE_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x94 - Interrupt Force&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">intf</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">intf::INTF_SPEC</span><span class="op">&gt;</span>,
    <span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;0x98 - Interrupt status after masking &amp; forcing&quot;</span>]</span>
    <span class="kw">pub</span> <span class="ident">ints</span>: <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">ints::INTS_SPEC</span><span class="op">&gt;</span>,
}
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP register accessor: an alias for `Reg&lt;ADDR_ENDP_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp::ADDR_ENDP_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Device address and endpoint control&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP1 register accessor: an alias for `Reg&lt;ADDR_ENDP1_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP1</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp1::ADDR_ENDP1_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 1. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp1</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP2 register accessor: an alias for `Reg&lt;ADDR_ENDP2_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP2</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp2::ADDR_ENDP2_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 2. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp2</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP3 register accessor: an alias for `Reg&lt;ADDR_ENDP3_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP3</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp3::ADDR_ENDP3_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 3. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp3</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP4 register accessor: an alias for `Reg&lt;ADDR_ENDP4_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP4</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp4::ADDR_ENDP4_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 4. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp4</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP5 register accessor: an alias for `Reg&lt;ADDR_ENDP5_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP5</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp5::ADDR_ENDP5_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 5. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp5</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP6 register accessor: an alias for `Reg&lt;ADDR_ENDP6_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP6</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp6::ADDR_ENDP6_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 6. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp6</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP7 register accessor: an alias for `Reg&lt;ADDR_ENDP7_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP7</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp7::ADDR_ENDP7_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 7. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp7</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP8 register accessor: an alias for `Reg&lt;ADDR_ENDP8_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP8</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp8::ADDR_ENDP8_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 8. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp8</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP9 register accessor: an alias for `Reg&lt;ADDR_ENDP9_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP9</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp9::ADDR_ENDP9_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 9. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp9</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP10 register accessor: an alias for `Reg&lt;ADDR_ENDP10_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP10</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp10::ADDR_ENDP10_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 10. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp10</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP11 register accessor: an alias for `Reg&lt;ADDR_ENDP11_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP11</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp11::ADDR_ENDP11_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 11. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp11</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP12 register accessor: an alias for `Reg&lt;ADDR_ENDP12_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP12</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp12::ADDR_ENDP12_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 12. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp12</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP13 register accessor: an alias for `Reg&lt;ADDR_ENDP13_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP13</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp13::ADDR_ENDP13_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 13. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp13</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP14 register accessor: an alias for `Reg&lt;ADDR_ENDP14_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP14</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp14::ADDR_ENDP14_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 14. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp14</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ADDR_ENDP15 register accessor: an alias for `Reg&lt;ADDR_ENDP15_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ADDR_ENDP15</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">addr_endp15::ADDR_ENDP15_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt endpoint 15. Only valid for HOST mode.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">addr_endp15</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;MAIN_CTRL register accessor: an alias for `Reg&lt;MAIN_CTRL_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">MAIN_CTRL</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">main_ctrl::MAIN_CTRL_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Main control register&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">main_ctrl</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;SOF_WR register accessor: an alias for `Reg&lt;SOF_WR_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">SOF_WR</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">sof_wr::SOF_WR_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">sof_wr</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;SOF_RD register accessor: an alias for `Reg&lt;SOF_RD_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">SOF_RD</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">sof_rd::SOF_RD_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">sof_rd</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;SIE_CTRL register accessor: an alias for `Reg&lt;SIE_CTRL_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">SIE_CTRL</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">sie_ctrl::SIE_CTRL_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;SIE control register&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">sie_ctrl</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;SIE_STATUS register accessor: an alias for `Reg&lt;SIE_STATUS_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">SIE_STATUS</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">sie_status::SIE_STATUS_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;SIE status register&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">sie_status</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;INT_EP_CTRL register accessor: an alias for `Reg&lt;INT_EP_CTRL_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">INT_EP_CTRL</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">int_ep_ctrl::INT_EP_CTRL_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;interrupt endpoint control register&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">int_ep_ctrl</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;BUFF_STATUS register accessor: an alias for `Reg&lt;BUFF_STATUS_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">BUFF_STATUS</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">buff_status::BUFF_STATUS_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">buff_status</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;BUFF_CPU_SHOULD_HANDLE register accessor: an alias for `Reg&lt;BUFF_CPU_SHOULD_HANDLE_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">BUFF_CPU_SHOULD_HANDLE</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">buff_cpu_should_handle::BUFF_CPU_SHOULD_HANDLE_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">buff_cpu_should_handle</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;EP_ABORT register accessor: an alias for `Reg&lt;EP_ABORT_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">EP_ABORT</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">ep_abort::EP_ABORT_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe to modify the buffer control register.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">ep_abort</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;EP_ABORT_DONE register accessor: an alias for `Reg&lt;EP_ABORT_DONE_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">EP_ABORT_DONE</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">ep_abort_done::EP_ABORT_DONE_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">ep_abort_done</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;EP_STALL_ARM register accessor: an alias for `Reg&lt;EP_STALL_ARM_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">EP_STALL_ARM</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">ep_stall_arm::EP_STALL_ARM_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Device: this bit must be set in conjunction with the `STALL` bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">ep_stall_arm</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;NAK_POLL register accessor: an alias for `Reg&lt;NAK_POLL_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">NAK_POLL</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">nak_poll::NAK_POLL_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">nak_poll</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;EP_STATUS_STALL_NAK register accessor: an alias for `Reg&lt;EP_STATUS_STALL_NAK_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">EP_STATUS_STALL_NAK</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">ep_status_stall_nak::EP_STATUS_STALL_NAK_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the endpoint control register.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">ep_status_stall_nak</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;USB_MUXING register accessor: an alias for `Reg&lt;USB_MUXING_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">USB_MUXING</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">usb_muxing::USB_MUXING_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Where to connect the USB controller. Should be to_phy by default.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">usb_muxing</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;USB_PWR register accessor: an alias for `Reg&lt;USB_PWR_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">USB_PWR</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">usb_pwr::USB_PWR_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable to switch over to the override value.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">usb_pwr</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;USBPHY_DIRECT register accessor: an alias for `Reg&lt;USBPHY_DIRECT_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">USBPHY_DIRECT</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">usbphy_direct::USBPHY_DIRECT_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;This register allows for direct control of the USB phy. Use in conjunction with usbphy_direct_override register to enable each override bit.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">usbphy_direct</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;USBPHY_DIRECT_OVERRIDE register accessor: an alias for `Reg&lt;USBPHY_DIRECT_OVERRIDE_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">USBPHY_DIRECT_OVERRIDE</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">usbphy_direct_override::USBPHY_DIRECT_OVERRIDE_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Override enable for each control in usbphy_direct&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">usbphy_direct_override</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;USBPHY_TRIM register accessor: an alias for `Reg&lt;USBPHY_TRIM_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">USBPHY_TRIM</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">usbphy_trim::USBPHY_TRIM_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Used to adjust trim values of USB phy pull down resistors.&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">usbphy_trim</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;INTR register accessor: an alias for `Reg&lt;INTR_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">INTR</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">intr::INTR_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Raw Interrupts&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">intr</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;INTE register accessor: an alias for `Reg&lt;INTE_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">INTE</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">inte::INTE_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt Enable&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">inte</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;INTF register accessor: an alias for `Reg&lt;INTF_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">INTF</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">intf::INTF_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt Force&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">intf</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;INTS register accessor: an alias for `Reg&lt;INTS_SPEC&gt;`&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">INTS</span> <span class="op">=</span> <span class="ident"><span class="kw">crate</span>::Reg</span><span class="op">&lt;</span><span class="ident">ints::INTS_SPEC</span><span class="op">&gt;</span>;
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Interrupt status after masking &amp; forcing&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">ints</span>;
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="rp2040_pac" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.64.0" ></div></body></html>