window.SIDEBAR_ITEMS = {"fn":[["clz32","Return the number of consecutive high order 0 bits of value. If value is zero, returns 32."],["connect_internal_flash","Restore all QSPI pad controls to their default state, and connect the SSI to the QSPI pads."],["copyright_string","The Raspberry Pi Trading Ltd copyright string."],["ctz32","Return the number of consecutive low order 0 bits of value. If value is zero, returns 32."],["flash_enter_cmd_xip","Configure the SSI to generate a standard 03h serial read command, with 24 address bits, upon each XIP access. This is a very slow XIP configuration, but is very widely supported. The debugger calls this function after performing a flash erase/programming operation, so that the freshly-programmed code and data is visible to the debug host, without having to know exactly what kind of flash device is connected."],["flash_exit_xip","First set up the SSI for serial-mode operations, then issue the fixed XIP exit sequence."],["flash_flush_cache","Flush and enable the XIP cache. Also clears the IO forcing on QSPI CSn, so that the SSI can drive the flashchip select as normal."],["flash_range_erase","Erase a count bytes, starting at addr (offset from start of flash). Optionally, pass a block erase command e.g. D8h block erase, and the size of the block erased by this command — this function will use the larger block erase where possible, for much higher erase speed. addr must be aligned to a 4096-byte sector, and count must be a multiple of 4096 bytes."],["flash_range_program","Program data to a range of flash addresses starting at `addr` (and offset from the start of flash) and `count` bytes in size. The value `addr` must be aligned to a 256-byte boundary, and `count` must be a multiple of 256."],["fplib_end","The end address of the floating point library code and data."],["fplib_start","The start address of the floating point library code and data."],["git_revision","The 8 most significant hex digits of the Bootrom git revision."],["memcpy","Copies n bytes starting at src to dest and returns dest. The results are undefined if the regions overlap."],["memcpy44","Copies n bytes starting at src to dest and returns dest. The results are undefined if the regions overlap."],["memset","Sets n bytes start at ptr to the value c and returns ptr"],["memset4","Sets n bytes start at ptr to the value c and returns ptr."],["popcount32","Return a count of the number of 1 bits in value."],["reset_to_usb_boot","Resets the RP2040 and uses the watchdog facility to re-start in BOOTSEL mode:"],["reverse32","Return the bits of value in the reverse order."],["rom_version_number","The version number of the rom."],["soft_double_table","This entry is only present in the V2 bootrom. See Table 182 in the RP2040 datasheet for the contents of this table."],["soft_float_table","See Table 180 in the RP2040 datasheet for the contents of this table."],["wait_for_vector","This is the method that is entered by core 1 on reset to wait to be launched by core 0. There are few cases where you should call this method (resetting core 1 is much better). This method does not return and should only ever be called on core 1."]],"mod":[["clz32","Additional access for the `clz32` ROM function."],["connect_internal_flash","Additional access for the `connect_internal_flash` ROM function."],["ctz32","Additional access for the `ctz32` ROM function."],["double_funcs","Functions using double-precision arithmetic (i.e. ‘f64’ in Rust terms)"],["flash_enter_cmd_xip","Additional access for the `flash_enter_cmd_xip` ROM function."],["flash_exit_xip","Additional access for the `flash_exit_xip` ROM function."],["flash_flush_cache","Additional access for the `flash_flush_cache` ROM function."],["flash_range_erase","Additional access for the `flash_range_erase` ROM function."],["flash_range_program","Additional access for the `flash_range_program` ROM function."],["float_funcs","ROM functions using single-precision arithmetic (i.e. ‘f32’ in Rust terms)"],["memcpy","Additional access for the `memcpy` ROM function."],["memcpy44","Additional access for the `memcpy44` ROM function."],["memset","Additional access for the `memset` ROM function."],["memset4","Additional access for the `memset4` ROM function."],["popcount32","Additional access for the `popcount32` ROM function."],["reset_to_usb_boot","Additional access for the `reset_to_usb_boot` ROM function."],["reverse32","Additional access for the `reverse32` ROM function."],["wait_for_vector","Additional access for the `wait_for_vector` ROM function."]],"type":[["RomFnTableCode","A bootrom function table code."]]};