window.SIDEBAR_ITEMS = {"enum":[["A","Channel A"],["B","Channel B"],["Pwm0","Slice ID representing slice 0"],["Pwm1","Slice ID representing slice 1"],["Pwm2","Slice ID representing slice 2"],["Pwm3","Slice ID representing slice 3"],["Pwm4","Slice ID representing slice 4"],["Pwm5","Slice ID representing slice 5"],["Pwm6","Slice ID representing slice 6"],["Pwm7","Slice ID representing slice 7"]],"mod":[["dyn_slice","Semi-internal enums mostly used in typelevel magic"]],"struct":[["Channel","A Channel from the Pwm subsystem."],["CountFallingEdge","Count once with each falling edge detected on the B pin"],["CountRisingEdge","Count once with each rising edge detected on the B pin"],["FreeRunning","Counter is free-running, and will count continuously whenever the slice is enabled"],["InputHighRunning","Count continuously when a high level is detected on the B pin"],["PwmPinToken","Stores the attached gpio pin."],["Slice","Pwm slice"],["Slices","Collection of all the individual [`Slices`]s"]],"trait":[["ChannelId","Used to pin traits to a specific channel (A or B)"],["NonPwmPinMode","Make sure we canâ€™t free an GPIO pin while still keeping it attached to pwm TODO: Maybe FunctionPWM should be private?"],["SliceId","Type-level `enum` for slice IDs"],["SliceMode","Mode for slice"],["ValidPwmInputPin","Marker trait for valid output pins"],["ValidPwmOutputPin","Marker trait for valid input pins (Channel B only)"],["ValidSliceInputMode","Type-level marker for tracking which slice modes are valid for which slices"],["ValidSliceMode","Type-level marker for tracking which slice modes are valid for which slices"]]};