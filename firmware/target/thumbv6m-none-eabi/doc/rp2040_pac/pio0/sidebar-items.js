window.SIDEBAR_ITEMS = {"mod":[["ctrl","PIO control register"],["dbg_cfginfo","The PIO hardware has some free parameters that may vary between chip products. These should be provided in the chip datasheet, but are also exposed here."],["dbg_padoe","Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0."],["dbg_padout","Read to sample the pad output values PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0."],["fdebug","FIFO debug register"],["flevel","FIFO levels"],["fstat","FIFO status register"],["input_sync_bypass","There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic from metastabilities. This increases input delay, and for fast synchronous IO (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this register corresponds to one GPIO. 0 -> input is synchronized (default) 1 -> synchronizer is bypassed If in doubt, leave this register as all zeroes."],["instr_mem","Write-only access to instruction memory location %s"],["intr","Raw Interrupts"],["irq","State machine IRQ flags register. Write 1 to clear. There are 8 state machine IRQ flags, which can be set, cleared, and waited on by the state machines. There’s no fixed association between flags and state machines – any state machine can use any flag."],["irq_force","Writing a 1 to each of these bits will forcibly assert the corresponding IRQ. Note this is different to the INTF register: writing here affects PIO internal state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and is not visible to the state machines."],["rxf","Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined."],["sm","Register block Cluster SM%s, containing SM*_CLKDIV, SM*_EXECCTRL, SM*_SHIFTCTRL, SM*_ADDR, SM*_INSTR, SM*_PINCTRL"],["sm_irq","Register block Cluster SM_IRQ%s, containing IRQ*_INTE, IRQ*_INTF, IRQ*_INTS"],["txf","Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO."]],"struct":[["RegisterBlock","Register block"],["SM","Register block"],["SM_IRQ","Register block"]],"type":[["CTRL","CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"],["DBG_CFGINFO","DBG_CFGINFO register accessor: an alias for `Reg<DBG_CFGINFO_SPEC>`"],["DBG_PADOE","DBG_PADOE register accessor: an alias for `Reg<DBG_PADOE_SPEC>`"],["DBG_PADOUT","DBG_PADOUT register accessor: an alias for `Reg<DBG_PADOUT_SPEC>`"],["FDEBUG","FDEBUG register accessor: an alias for `Reg<FDEBUG_SPEC>`"],["FLEVEL","FLEVEL register accessor: an alias for `Reg<FLEVEL_SPEC>`"],["FSTAT","FSTAT register accessor: an alias for `Reg<FSTAT_SPEC>`"],["INPUT_SYNC_BYPASS","INPUT_SYNC_BYPASS register accessor: an alias for `Reg<INPUT_SYNC_BYPASS_SPEC>`"],["INSTR_MEM","INSTR_MEM register accessor: an alias for `Reg<INSTR_MEM_SPEC>`"],["INTR","INTR register accessor: an alias for `Reg<INTR_SPEC>`"],["IRQ","IRQ register accessor: an alias for `Reg<IRQ_SPEC>`"],["IRQ_FORCE","IRQ_FORCE register accessor: an alias for `Reg<IRQ_FORCE_SPEC>`"],["RXF","RXF register accessor: an alias for `Reg<RXF_SPEC>`"],["TXF","TXF register accessor: an alias for `Reg<TXF_SPEC>`"]]};