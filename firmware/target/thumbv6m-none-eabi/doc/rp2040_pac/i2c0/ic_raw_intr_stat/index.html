<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="I2C Raw Interrupt Status Register"><meta name="keywords" content="rust, rustlang, rust-lang, ic_raw_intr_stat"><title>rp2040_pac::i2c0::ic_raw_intr_stat - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../rp2040_pac/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../rp2040_pac/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Module ic_raw_intr_stat</a></h2><div class="sidebar-elems"><section><div class="block"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../rp2040_pac/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Module <a href="../../index.html">rp2040_pac</a>::<wbr><a href="../index.html">i2c0</a>::<wbr><a class="mod" href="#">ic_raw_intr_stat</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../../src/rp2040_pac/i2c0/ic_raw_intr_stat.rs.html#1-840">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>I2C Raw Interrupt Status Register</p>
<p>Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ACTIVITY_R.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::ACTIVITY_R struct">ACTIVITY_R</a></div><div class="item-right docblock-short"><p>Field <code>ACTIVITY</code> reader - This bit captures DW_apb_i2c activity and stays set until it is cleared. There are four ways to clear it: - Disabling the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.GEN_CALL_R.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::GEN_CALL_R struct">GEN_CALL_R</a></div><div class="item-right docblock-short"><p>Field <code>GEN_CALL</code> reader - Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.IC_RAW_INTR_STAT_SPEC.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::IC_RAW_INTR_STAT_SPEC struct">IC_RAW_INTR_STAT_SPEC</a></div><div class="item-right docblock-short"><p>I2C Raw Interrupt Status Register</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.R.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::R struct">R</a></div><div class="item-right docblock-short"><p>Register <code>IC_RAW_INTR_STAT</code> reader</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RD_REQ_R.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::RD_REQ_R struct">RD_REQ_R</a></div><div class="item-right docblock-short"><p>Field <code>RD_REQ</code> reader - This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor reads the IC_CLR_RD_REQ register.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RESTART_DET_R.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::RESTART_DET_R struct">RESTART_DET_R</a></div><div class="item-right docblock-short"><p>Field <code>RESTART_DET</code> reader - Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RX_DONE_R.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::RX_DONE_R struct">RX_DONE_R</a></div><div class="item-right docblock-short"><p>Field <code>RX_DONE</code> reader - When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RX_FULL_R.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::RX_FULL_R struct">RX_FULL_R</a></div><div class="item-right docblock-short"><p>Field <code>RX_FULL</code> reader - Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RX_OVER_R.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::RX_OVER_R struct">RX_OVER_R</a></div><div class="item-right docblock-short"><p>Field <code>RX_OVER</code> reader - Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RX_UNDER_R.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::RX_UNDER_R struct">RX_UNDER_R</a></div><div class="item-right docblock-short"><p>Field <code>RX_UNDER</code> reader - Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.START_DET_R.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::START_DET_R struct">START_DET_R</a></div><div class="item-right docblock-short"><p>Field <code>START_DET</code> reader - Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.STOP_DET_R.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::STOP_DET_R struct">STOP_DET_R</a></div><div class="item-right docblock-short"><p>Field <code>STOP_DET</code> reader - Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TX_ABRT_R.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::TX_ABRT_R struct">TX_ABRT_R</a></div><div class="item-right docblock-short"><p>Field <code>TX_ABRT</code> reader - This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a ‘transmit abort’. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TX_EMPTY_R.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::TX_EMPTY_R struct">TX_EMPTY_R</a></div><div class="item-right docblock-short"><p>Field <code>TX_EMPTY</code> reader - The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed. It is automatically cleared by hardware when the buffer level goes above the threshold. When IC_ENABLE[0]
is set to 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer any activity, then with ic_en=0, this bit is set to 0.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TX_OVER_R.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::TX_OVER_R struct">TX_OVER_R</a></div><div class="item-right docblock-short"><p>Field <code>TX_OVER</code> reader - Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ACTIVITY_A.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::ACTIVITY_A enum">ACTIVITY_A</a></div><div class="item-right docblock-short"><p>This bit captures DW_apb_i2c activity and stays set until it is cleared. There are four ways to clear it: - Disabling the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the DW_apb_i2c module is idle, this bit remains set until cleared, indicating that there was activity on the bus.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.GEN_CALL_A.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::GEN_CALL_A enum">GEN_CALL_A</a></div><div class="item-right docblock-short"><p>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling DW_apb_i2c or when the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received data in the Rx buffer.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.RD_REQ_A.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::RD_REQ_A enum">RD_REQ_A</a></div><div class="item-right docblock-short"><p>This bit is set to 1 when DW_apb_i2c is acting as a slave and another I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the IC_DATA_CMD register. This bit is set to 0 just after the processor reads the IC_CLR_RD_REQ register.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.RESTART_DET_A.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::RESTART_DET_A enum">RESTART_DET_A</a></div><div class="item-right docblock-short"><p>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.RX_DONE_A.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::RX_DONE_A enum">RX_DONE_A</a></div><div class="item-right docblock-short"><p>When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.RX_FULL_A.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::RX_FULL_A enum">RX_FULL_A</a></div><div class="item-right docblock-short"><p>Set when the receive buffer reaches or goes above the RX_TL threshold in the IC_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.RX_OVER_A.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::RX_OVER_A enum">RX_OVER_A</a></div><div class="item-right docblock-short"><p>Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The DW_apb_i2c acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.RX_UNDER_A.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::RX_UNDER_A enum">RX_UNDER_A</a></div><div class="item-right docblock-short"><p>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.START_DET_A.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::START_DET_A enum">START_DET_A</a></div><div class="item-right docblock-short"><p>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.STOP_DET_A.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::STOP_DET_A enum">STOP_DET_A</a></div><div class="item-right docblock-short"><p>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether DW_apb_i2c is operating in slave or master mode.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.TX_ABRT_A.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::TX_ABRT_A enum">TX_ABRT_A</a></div><div class="item-right docblock-short"><p>This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a ‘transmit abort’. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.TX_EMPTY_A.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::TX_EMPTY_A enum">TX_EMPTY_A</a></div><div class="item-right docblock-short"><p>The behavior of the TX_EMPTY interrupt status differs based on the TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This bit is set to 1 when the transmit buffer is at or below the threshold value set in the IC_TX_TL register and the transmission of the address/data from the internal shift register for the most recently popped command is completed. It is automatically cleared by hardware when the buffer level goes above the threshold. When IC_ENABLE[0]
is set to 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer any activity, then with ic_en=0, this bit is set to 0.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.TX_OVER_A.html" title="rp2040_pac::i2c0::ic_raw_intr_stat::TX_OVER_A enum">TX_OVER_A</a></div><div class="item-right docblock-short"><p>Set during transmit if the transmit buffer is filled to IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.</p>
</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="rp2040_pac" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.64.0" ></div></body></html>